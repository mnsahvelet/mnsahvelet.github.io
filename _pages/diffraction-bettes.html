---
title: "Diffraction Calculator: Semi-infinite Breakwater (Bettes)"
permalink: /tools/diffraction/bettes/
layout: single
author_profile: false
---

<style>
  .tool-wrap{ max-width: 980px; margin: 0 auto; }
  .tool-title{ font-size: 2rem; font-weight: 700; margin: 0 0 0.4rem 0; }
  .tool-sub{ margin: 0 0 1.2rem 0; opacity: 0.9; }
  .tool-grid{ display: grid; grid-template-columns: 340px 1fr; gap: 18px; align-items: start; }
  .panel{ background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 14px; }
  .panel h3{ margin: 0 0 10px 0; font-size: 1.05rem; }
  .row{ display: grid; grid-template-columns: 1fr 120px; gap: 10px; align-items: center; margin-bottom: 10px; }
  .row label{ font-weight: 600; }
  .row input{ width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.18); background: rgba(0,0,0,0.20); color: inherit; }
  .row small{ opacity: 0.85; font-weight: 400; }
  .row-2{ display: grid; grid-template-columns: 1fr; margin-top: 8px; margin-bottom: 8px; }
  .btn{ display: inline-block; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.20); background: rgba(255,255,255,0.10); color: inherit; cursor: pointer; font-weight: 700; }
  .btn:disabled{ opacity: 0.6; cursor: not-allowed; }
  .note{ font-size: 0.92rem; opacity: 0.9; line-height: 1.35; }
  .results{ font-size: 0.95rem; border-collapse: collapse; width: 100%; }
  .results td{ padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.10); vertical-align: top; }
  .results td:first-child{ width: 140px; opacity: 0.9; }
  .canvas-wrap{ position: relative; width: 100%; overflow: hidden; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); background: rgba(0,0,0,0.22); }
  canvas{ display:block; width:100%; height:auto; }
  .status{ margin-top: 10px; opacity: 0.9; font-size: 0.92rem; }
  .legend{ display:flex; align-items:center; gap:10px; margin-top: 10px; }
  .legend-bar{ height: 10px; flex: 1; border-radius: 999px; border: 1px solid rgba(255,255,255,0.18);
               background: linear-gradient(90deg, #30123b, #4145ab, #2a7ab9, #1aa287, #5ec962, #b8de29, #fde725); }
  .legend-label{ font-size: 0.9rem; opacity: 0.9; min-width: 88px; text-align: right; }
  @media (max-width: 900px){ .tool-grid{ grid-template-columns: 1fr; } }
</style>

<div class="tool-wrap">
  <div class="tool-title">Diffraction Calculator</div>
  <p class="tool-sub">
    Semi-infinite breakwater diffraction coefficient <strong>K<sub>d</sub>(x,y)</strong> using the Bettes-style analytic formulation.
    Angle convention follows your MATLAB tab: θ is measured from +x, and θ<sub>inc</sub> is the incident angle in the same frame.
  </p>

  <div class="tool-grid">
    <div class="panel">
      <h3>Inputs</h3>

      <div class="row">
        <label for="T">T (s)</label>
        <input id="T" type="number" step="0.01" value="5">
      </div>

      <div class="row">
        <label for="h">d (m) <small>(water depth)</small></label>
        <input id="h" type="number" step="0.01" value="10">
      </div>

      <div class="row">
        <label for="L">L (m) <small>(optional override)</small></label>
        <input id="L" type="number" step="0.001" value="">
      </div>

      <div class="row">
        <label for="dx">dx (m)</label>
        <input id="dx" type="number" step="0.01" value="1">
      </div>

      <div class="row">
        <label for="dy">dy (m)</label>
        <input id="dy" type="number" step="0.01" value="1">
      </div>

      <div class="row">
        <label for="xMax">xMax (m)</label>
        <input id="xMax" type="number" step="1" value="100">
      </div>

      <div class="row">
        <label for="yMax">yMax (m)</label>
        <input id="yMax" type="number" step="1" value="100">
      </div>

      <div class="row">
        <label for="thetaInc">θ<sub>inc</sub> (deg)</label>
        <input id="thetaInc" type="number" step="0.1" value="90">
      </div>

      <div class="row-2">
        <label style="display:flex; gap:10px; align-items:center; font-weight:600;">
          <input id="nondim" type="checkbox" checked>
          Plot nondimensional (x/L, y/L)
        </label>
      </div>

      <div class="row-2" style="display:flex; gap:10px; align-items:center;">
        <button id="plotBtn" class="btn" type="button">Plot Semi Infinite Kd Map</button>
        <button id="stopBtn" class="btn" type="button" disabled>Stop</button>
      </div>

      <h3 style="margin-top:14px;">Results</h3>
      <table class="results">
        <tr><td>ω (rad/s)</td><td id="out_omega">–</td></tr>
        <tr><td>k (1/m)</td><td id="out_k">–</td></tr>
        <tr><td>L (m)</td><td id="out_L">–</td></tr>
        <tr><td>kh (-)</td><td id="out_kh">–</td></tr>
      </table>

      <div class="status" id="status">JS not loaded yet…</div>
    </div>

    <div class="panel">
      <h3>Map</h3>
      <div class="canvas-wrap">
        <canvas id="map" width="1000" height="750"></canvas>
      </div>

      <div class="legend">
        <div class="legend-label">K<sub>d</sub>: 0</div>
        <div class="legend-bar"></div>
        <div class="legend-label">1</div>
      </div>

      <div class="note" style="margin-top:10px;">
        Breakwater is drawn as a thick black line on x=0 for y≥0 (semi-infinite). Domain is x≥0, 0≤y≤yMax.
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const g = 9.81;
  const el = (id) => document.getElementById(id);

  const TEl      = el("T");
  const hEl      = el("h");
  const LEl      = el("L");
  const dxEl     = el("dx");
  const dyEl     = el("dy");
  const xMaxEl   = el("xMax");
  const yMaxEl   = el("yMax");
  const thIncEl  = el("thetaInc");
  const nondimEl = el("nondim");

  const plotBtn  = el("plotBtn");
  const stopBtn  = el("stopBtn");

  const statusEl = el("status");
  const outOmega = el("out_omega");
  const outK     = el("out_k");
  const outL     = el("out_L");
  const outKh    = el("out_kh");

  const canvas = el("map");
  const ctx = canvas.getContext("2d");

  // If this prints, JS is running for sure
  statusEl.textContent = "JS loaded. Click Plot.";

  let stopFlag = false;

  class C {
    constructor(re, im){ this.re = re; this.im = im; }
    static add(a,b){ return new C(a.re+b.re, a.im+b.im); }
    static mul(a,b){ return new C(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }
    static expi(phi){ return new C(Math.cos(phi), Math.sin(phi)); }
    static abs(a){ return Math.hypot(a.re, a.im); }
  }

  function solveK(T, h){
    const omega = 2*Math.PI / T;
    let k = (omega*omega)/g;
    for(let it=0; it<30; it++){
      const kh = k*h;
      const th = Math.tanh(kh);
      const sech = 1/Math.cosh(kh);
      const sech2 = sech*sech;

      const f  = g*k*th - omega*omega;
      const df = g*th + g*k*h*sech2;

      const dk = -f/df;
      k += dk;

      if(!isFinite(k) || k<=0) break;
      if(Math.abs(dk)/k < 1e-12) break;
    }
    return {omega, k, L: 2*Math.PI/k, kh: k*h};
  }

  function fresnelCS(x){
    const sign = (x < 0) ? -1 : 1;
    x = Math.abs(x);

    if (x < 1e-6){
      const x2 = x*x;
      return { C: sign*(x - (Math.PI*Math.PI*x2*x)/40), S: sign*((Math.PI*x2)/6) };
    }

    const x2 = x*x;
    const t = 0.5*Math.PI*x2;

    if (x > 1.6){
      const u  = 1/(Math.PI*x);
      const u2 = u*u;

      const f = u*(1 - 0.5*u2 + 0.75*u2*u2 - 1.875*u2*u2*u2);
      const gg = u2*(1 - 1.5*u2 + 3.75*u2*u2 - 13.125*u2*u2*u2);

      const ct = Math.cos(t);
      const st = Math.sin(t);

      const Cx = 0.5 + f*st - gg*ct;
      const Sx = 0.5 - f*ct - gg*st;

      return { C: sign*Cx, S: sign*Sx };
    }

    let Csum = 0;
    let Ssum = 0;

    const a = Math.PI/2;
    let termC = x;
    let termS = a*x*x*x/3;

    Csum += termC;
    Ssum += termS;

    for(let n=1; n<30; n++){
      const num = -a*a*x*x*x*x;

      const denC = (2*n-1)*(2*n)*(4*n+1);
      const denCprev = (4*(n-1)+1);
      termC = termC * num * denCprev / denC;

      const denS = (2*n)*(2*n+1)*(4*n+3);
      const denSprev = (4*(n-1)+3);
      termS = termS * num * denSprev / denS;

      Csum += termC;
      Ssum += termS;

      if(Math.abs(termC) + Math.abs(termS) < 1e-12) break;
    }

    return { C: sign*Csum, S: sign*Ssum };
  }

  function bettesF(sigma){
    const cs = fresnelCS(sigma);
    const M = cs.C;
    const N = cs.S;

    const inside = new C(0.5 + M, -(0.5 + N));
    const pref   = new C(0.5, 0.5);
    return C.mul(pref, inside);
  }

  function bettesKdAtPoint(r, theta, L, theta0){
    if (r === 0) return 0;

    const k = 2*Math.PI/L;
    const fac = 2*Math.sqrt(k*r/Math.PI);

    const s1 =  fac * Math.sin(0.5*(theta - theta0));
    const s2 = -fac * Math.sin(0.5*(theta + theta0));

    const F1 = bettesF(s1);
    const F2 = bettesF(s2);

    const ph1 = -k*r*Math.cos(theta - theta0);
    const ph2 = -k*r*Math.cos(theta + theta0);

    const t1 = C.mul(F1, C.expi(ph1));
    const t2 = C.mul(F2, C.expi(ph2));

    return C.abs(C.add(t1, t2));
  }

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function colormapViridisLike(t){
    t = clamp01(t);
    const stops = [
      [0.0,  48,  18,  59],
      [0.2,  65,  70, 171],
      [0.4,  42, 122, 185],
      [0.6,  26, 162, 135],
      [0.8,  94, 201,  98],
      [1.0, 253, 231,  37],
    ];
    for(let i=0; i<stops.length-1; i++){
      const a = stops[i], b = stops[i+1];
      if(t >= a[0] && t <= b[0]){
        const u = (t-a[0])/(b[0]-a[0]);
        return [
          Math.round(a[1] + u*(b[1]-a[1])),
          Math.round(a[2] + u*(b[2]-a[2])),
          Math.round(a[3] + u*(b[3]-a[3])),
        ];
      }
    }
    return [253,231,37];
  }

  function clearCanvas(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
  }

  function drawBreakwaterLine(y0Pix, y1Pix, xPix){
    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,0.95)";
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.moveTo(xPix, y0Pix);
    ctx.lineTo(xPix, y1Pix);
    ctx.stroke();
    ctx.restore();
  }

  function drawAxesLabels(xLabel, yLabel){
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(xLabel, 18, canvas.height - 14);

    ctx.translate(14, canvas.height/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();
  }

  async function computeAndPlot(){
    stopFlag = false;
    plotBtn.disabled = true;
    stopBtn.disabled = false;

    const T = parseFloat(TEl.value);
    const h = parseFloat(hEl.value);
    const L_override = parseFloat(LEl.value);

    const dx = parseFloat(dxEl.value);
    const dy = parseFloat(dyEl.value);
    const xMax = parseFloat(xMaxEl.value);
    const yMax = parseFloat(yMaxEl.value);
    const thetaIncDeg = parseFloat(thIncEl.value);

    if(!(T>0) || !(h>0) || !(dx>0) || !(dy>0) || !(xMax>0) || !(yMax>0)){
      statusEl.textContent = "Invalid inputs: all must be > 0.";
      plotBtn.disabled = false;
      stopBtn.disabled = true;
      return;
    }

    statusEl.textContent = "Computing…";

    const disp = solveK(T, h);
    const L = (isFinite(L_override) && L_override > 0) ? L_override : disp.L;

    const k = 2*Math.PI/L;
    const omega = disp.omega;
    const kh = k*h;

    outOmega.textContent = omega.toFixed(6);
    outK.textContent     = k.toFixed(10);
    outL.textContent     = L.toFixed(4);
    outKh.textContent    = kh.toFixed(4);

    const nx = Math.floor(xMax/dx) + 1;
    const ny = Math.floor(yMax/dy) + 1;

    const kd = new Float32Array(nx*ny);
    const theta0 = thetaIncDeg * Math.PI/180;

    const chunkRows = 6;
    let maxKd = 0;

    for(let iy=0; iy<ny; iy+=chunkRows){
      if(stopFlag) break;

      const yEnd = Math.min(ny, iy+chunkRows);
      for(let j=iy; j<yEnd; j++){
        const y = j*dy;
        for(let i=0; i<nx; i++){
          const x = i*dx;
          const r = Math.hypot(x,y);
          const theta = Math.atan2(y,x);

          const val = bettesKdAtPoint(r, theta, L, theta0);
          const idx = j*nx + i;
          kd[idx] = val;
          if(val > maxKd) maxKd = val;
        }
      }

      statusEl.textContent = `Computing… (${Math.round(100*yEnd/ny)}%)`;
      await new Promise(requestAnimationFrame);
    }

    if(stopFlag){
      statusEl.textContent = "Stopped.";
      plotBtn.disabled = false;
      stopBtn.disabled = true;
      return;
    }

    const invMax = 1/(maxKd + 1e-12);

    clearCanvas();

    const padL = 54, padB = 40, padT = 14, padR = 14;
    const W = canvas.width  - padL - padR;
    const H = canvas.height - padT - padB;

    const img = ctx.createImageData(W, H);
    const data = img.data;

    for(let py=0; py<H; py++){
      const yPhys = (H-1-py) * (yMax/(H-1));
      const jy = Math.min(ny-1, Math.round(yPhys/dy));

      for(let px=0; px<W; px++){
        const xPhys = px * (xMax/(W-1));
        const ix = Math.min(nx-1, Math.round(xPhys/dx));

        const v = kd[jy*nx + ix] * invMax;
        const rgb = colormapViridisLike(v);

        const p = 4*(py*W + px);
        data[p+0] = rgb[0];
        data[p+1] = rgb[1];
        data[p+2] = rgb[2];
        data[p+3] = 255;
      }
    }

    ctx.putImageData(img, padL, padT);

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.lineWidth = 1;
    ctx.strokeRect(padL+0.5, padT+0.5, W-1, H-1);
    ctx.restore();

    drawBreakwaterLine(padT, padT + H, padL);

    const useNondim = nondimEl.checked;
    drawAxesLabels(useNondim ? "x/L" : "x (m)", useNondim ? "y/L" : "y (m)");

    statusEl.textContent = `Done. Grid: ${nx} × ${ny}.`;
    plotBtn.disabled = false;
    stopBtn.disabled = true;
  }

  plotBtn.addEventListener("click", (e) => { e.preventDefault(); computeAndPlot(); });
  stopBtn.addEventListener("click", () => { stopFlag = true; stopBtn.disabled = true; });

  // initial blank so you see the canvas exists
  clearCanvas();
  ctx.fillStyle = "rgba(255,255,255,0.08)";
  ctx.fillRect(60, 60, 320, 130);
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.font = "18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("Ready. Click Plot.", 80, 130);
});
</script>
